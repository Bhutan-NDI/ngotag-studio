name: Build and deploy Node.js app to ECSsdc

on:
  push:
    tags:
      - 'qa-*'

env:
  ECR_IMAGE_TAG: "FRONTEND_V_${{ github.run_number }}"
  ECR_REPOSITORY: "qa-services"
  AWS_REGION: "ap-southeast-1"
  CLUSTER: "QA-NGOTAG-CLUSTER"

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
    # ────────────────────────────────────────────────────────────────
    # 1. Gated tag push
    # ────────────────────────────────────────────────────────────────
    - name: Check if tag creator is allowed
      id: check-user
      run: |
        ALLOWED_USERS=("Chimi1999" "dev-dungana")
        echo "Tag pushed by: ${{ github.actor }}"
        [[ " ${ALLOWED_USERS[*]} " =~ " ${{ github.actor }} " ]] \
          && echo "is_allowed=true"  >> $GITHUB_OUTPUT \
          || echo "is_allowed=false" >> $GITHUB_OUTPUT

    - name: Delete tag if unauthorized
      if: steps.check-user.outputs.is_allowed != 'true'
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        TAG_NAME=${GITHUB_REF#refs/tags/}
        echo "Unauthorized tag push by ${{ github.actor }}. Deleting $TAG_NAME"
        curl -s -X DELETE -H "Authorization: token $GITHUB_TOKEN" \
          "https://api.github.com/repos/${{ github.repository }}/git/refs/tags/$TAG_NAME"
        exit 1

    # ────────────────────────────────────────────────────────────────
    # 2. Build & push image
    # ────────────────────────────────────────────────────────────────
    - uses: actions/checkout@v2

    - uses: docker/setup-buildx-action@v1

    - uses: aws-actions/configure-aws-credentials@v3
      with:
        role-to-assume: ${{ secrets.IAM_ROLE }}
        aws-region: ${{ env.AWS_REGION }}

    - id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1

    - name: Create .env file for the build
      run: |
        cat <<EOF > .env
        PUBLIC_BASE_URL=${{ secrets.QA_PUBLIC_BASE_URL }}
        PUBLIC_CRYPTO_PRIVATE_KEY=${{ secrets.QA_PUBLIC_CRYPTO_PRIVATE_KEY }}
        PUBLIC_PLATFORM_NAME=${{ secrets.PUBLIC_PLATFORM_NAME }}
        PUBLIC_PLATFORM_LOGO=${{ secrets.QA_PUBLIC_PLATFORM_LOGO }}
        PUBLIC_POWERED_BY=${{ secrets.PUBLIC_POWERED_BY }}
        PUBLIC_PLATFORM_WEB_URL=${{ secrets.QA_PUBLIC_PLATFORM_WEB_URL }}
        PUBLIC_POWERED_BY_URL=${{ secrets.PUBLIC_POWERED_BY_URL }}
        PUBLIC_PLATFORM_SUPPORT_EMAIL=${{ secrets.PUBLIC_PLATFORM_SUPPORT_EMAIL }}
        PUBLIC_SHOW_NAME_AS_LOGO=${{ secrets.PUBLIC_SHOW_NAME_AS_LOGO }}
        PUBLIC_ALLOW_DOMAIN=${{ secrets.QA_PUBLIC_ALLOW_DOMAIN }}
        EOF

    - name: Build, tag & push Docker image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: "FRONTEND_V_${{ github.run_number }}"
      run: |
        docker build -t $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG .
        docker push   $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG
        docker image list

    # Expose variables to later steps
    - run: |
        echo "ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}" >> $GITHUB_ENV
        echo "IMAGE_TAG=FRONTEND_V_${{ github.run_number }}"          >> $GITHUB_ENV

    - name: Retrieve ECR repository URI
      run: |
        REPOSITORY_URI=$(aws ecr describe-repositories \
            --repository-names ${{ env.ECR_REPOSITORY }} \
            --region ${{ env.AWS_REGION }} \
            --query 'repositories[0].repositoryUri' --output text)
        echo "REPOSITORY_URI=${REPOSITORY_URI}" >> $GITHUB_ENV

    # ────────────────────────────────────────────────────────────────
    # 3. Pull, patch, and register task definition
    # ────────────────────────────────────────────────────────────────
    - name: Generate patched task definition
      env:
        TASKDEF_FAMILY: "QA-FRONTEND_UI_TASKDEF"
      run: |
        mkdir -p qa-taskdef

        echo "Fetching latest task definition $TASKDEF_FAMILY..."
        aws ecs describe-task-definition \
          --task-definition "$TASKDEF_FAMILY" \
          --region ${{ env.AWS_REGION }} \
          --query 'taskDefinition' --output json \
          > qa-taskdef/frontend-taskdef.json

        # Patch executionRoleArn
        sed -i -E \
          "s#\"executionRoleArn\": \"arn:aws:iam::[0-9]+:role/ecsTaskExecutionRole\"#\"executionRoleArn\": \"arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/ecsTaskExecutionRole\"#" \
          qa-taskdef/frontend-taskdef.json

        # Patch container image
        IMAGE_URI="${REPOSITORY_URI}:${IMAGE_TAG}"
        jq --arg img "$IMAGE_URI" '.containerDefinitions[].image = $img' \
          qa-taskdef/frontend-taskdef.json > qa-taskdef/tmp.json
        mv qa-taskdef/tmp.json qa-taskdef/frontend-taskdef.json

        # Display patched file for troubleshooting
        echo "----- patched task definition -----"
        cat qa-taskdef/frontend-taskdef.json
        echo "-----------------------------------"

    - name: Register new revision
      id: register
      run: |
        FAMILY=$(jq -r '.family' qa-taskdef/frontend-taskdef.json)
        NEW_REVISION=$(aws ecs register-task-definition \
          --cli-input-json file://qa-taskdef/frontend-taskdef.json \
          --region ${{ env.AWS_REGION }} \
          --query 'taskDefinition.revision' --output text)
        echo "FAMILY=$FAMILY"             >> $GITHUB_OUTPUT
        echo "REVISION=$NEW_REVISION"     >> $GITHUB_OUTPUT
        echo "Registered $FAMILY:$NEW_REVISION"

    # ────────────────────────────────────────────────────────────────
    # 4. Update (or create) the service
    # ────────────────────────────────────────────────────────────────
    - name: Deploy to ECS service
      run: |
        SERVICE_NAME="frontend-service"
        CLUSTER="${{ env.CLUSTER }}"
        FAMILY="${{ steps.register.outputs.FAMILY }}"
        REVISION="${{ steps.register.outputs.REVISION }}"

        echo "Updating service $SERVICE_NAME to $FAMILY:$REVISION"

        # Does the service exist?
        SERVICE_INFO=$(aws ecs describe-services \
          --services "$SERVICE_NAME" \
          --cluster "$CLUSTER" \
          --region ${{ env.AWS_REGION }} \
          --query 'services[0]' --output json 2>/dev/null || true)

        if [[ "$SERVICE_INFO" == "null" || -z "$SERVICE_INFO" ]]; then
          echo "Service not found – creating it (desiredCount=1)..."
          aws ecs create-service \
            --cluster "$CLUSTER" \
            --service-name "$SERVICE_NAME" \
            --task-definition "$FAMILY:$REVISION" \
            --desired-count 1 \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[subnet-xxxxxxxx],securityGroups=[sg-xxxxxxxx],assignPublicIp=ENABLED}" \
            --region ${{ env.AWS_REGION }}
        else
          DESIRED=$(echo "$SERVICE_INFO" | jq -r '.desiredCount')
          [[ "$DESIRED" == "0" || -z "$DESIRED" ]] && DESIRED=1
          aws ecs update-service \
            --cluster "$CLUSTER" \
            --service "$SERVICE_NAME" \
            --task-definition "$FAMILY:$REVISION" \
            --desired-count "$DESIRED" \
            --region ${{ env.AWS_REGION }}
        fi
